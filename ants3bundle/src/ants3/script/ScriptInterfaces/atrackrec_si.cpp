#include "atrackrec_si.h"
#include "aeventtrackingrecord.h"
#include "atrackingdataimporter.h"

#include <cmath>

ATrackRec_SI::ATrackRec_SI() :
    AScriptInterface(), EventRecord(AEventTrackingRecord::create())
{
    Help["open"] = "Select a file with the tracking history";

    Help["countEvents"] = "Count number of events in the opened file";

    Help["setEvent"] = "Select a particular event in the opened file";
    Help["nextEvent"] = "Select next event in the opened file. Return false if there are no more events";

    Help["countPrimaries"] = "Count number of primaries in the selected event";
    Help["setPrimary"] = "Select a particular primary in the selected event";

    Help["recordToString"] = "Makes a string with the tracking record for the selected primary. If the argument is true, includes secondaries";

    Help["getTrackRecord"] = "Return [string_ParticleName, bool_IsSecondary, int_NumberOfSecondaries, int_NumberOfTrackingSteps] for the currently selected particle";
    Help["getProductionProcess"] = "Return production process for the selected secondary. The result is empty string if a primary particle is selected";

    Help["countSteps"] = "Count number of tracking steps for the selected particle";
    Help["countSecondaries"] = "Count number of secondaries generated by the selected particle";

    Help["makeStep"] = "Go to next tracking step of the curently selected particle. Returns false if there are no more steps";
    Help["gotoFirstStep"] = "Go to the first tracking step of the curently selected particle.";
    Help["gotoLastStep"] = "Go to the last tracking step of the curently selected particle.";
    Help["gotoStep"] = "Go to the particular tracking step of the curently selected particle.";
    Help["gotoNextProcessStep"] = "Go to the next tracking step of the curently selected particle with the given process name.";
    Help["gotoNextNonTransportationStep"] = "Go to the next tracking step of the curently selected particle which is not creation, transportation, or geometry exit.\n"
                                            "Note that transportation steps can have energy deposition!";


    Help["getPreStepRecord"] = "Return [ [X,Y,Z], Time, [MatIndex, VolumeName, VolumeIndex], Energy, DepositedEnergy, ProcessName, TragetIsotope(for hadronic), indexesOfSecondaries[] ]\n"
                             "XYZ in mm, Time in ns, Energies in keV, [MatVolIndex] array is empty if node does not exist, indexesOfSec is array with ints";
    Help["getPostStepRecord"] = "Return [ [X,Y,Z], Time, [MatIndex, VolumeName, VolumeIndex], Energy, DepositedEnergy, ProcessName, TragetIsotope(for hadronic), indexesOfSecondaries[] ]\n"
                               "XYZ in mm, Time in ns, Energies in keV, [MatVolIndex] array is empty if node does not exist, indexesOfSec is array with ints";

    Help["getDirectionsApproximation"] = "Get array of two unit vectors: the first one connects the previous and the current step position, the second one connects the current and the next positions";

    Help["hadPriorInteraction"] = "Check if the particle had interactions (non-transportation steps) before the current one";

    Help["enterSecondary"] = "Enter a particular secondary of the currently selected particle. Aborts if index is invalid!";
    Help["exitSecondary"] = "Exits the currently selected secondary. The tracking step is restored to the position when enterSecondary was called.";
}

ATrackRec_SI::~ATrackRec_SI()
{
    delete EventRecord; EventRecord = nullptr;
    delete Importer; Importer = nullptr;
}

void ATrackRec_SI::open(QString fileName)
{
    FileName = fileName;

    delete Importer; Importer = new ATrackingDataImporter(FileName);
    if (!Importer->ErrorString.isEmpty())
    {
        abort("Error accessing the tracking history file:\n" + Importer->ErrorString);
        return;
    }

    NumEvents = -1;
}

bool ATrackRec_SI::checkImporter()
{
    if (!Importer)
    {
        abort("Use configure() method to setup the file reader");
        return false;
    }
    return true;
}

int ATrackRec_SI::countEvents()
{
    if (!checkImporter()) return 0;

    if (NumEvents != -1) return NumEvents;
    NumEvents = Importer->countEvents();
    return NumEvents;
}

void ATrackRec_SI::setEvent(int iEvent)
{
    if (!checkImporter()) return;

    bool ok = Importer->extractEvent(iEvent, EventRecord);
    if (!ok) abort(Importer->ErrorString);

    CurrentEvent = iEvent;

    if (countPrimaries() > 0) setPrimary(0);
    else ParticleRecord = nullptr;
}

bool ATrackRec_SI::nextEvent()
{
    if (!checkImporter()) return false;

    bool ok = Importer->extractEvent(CurrentEvent+1, EventRecord);
    if (!ok) return false;

    CurrentEvent++;

    if (countPrimaries() > 0) setPrimary(0);
    else ParticleRecord = nullptr;
    return true;
}

int ATrackRec_SI::countPrimaries()
{
    return EventRecord->countPrimaries();
}

void ATrackRec_SI::setPrimary(int iPrimary)
{
    if (iPrimary < 0 || iPrimary >= EventRecord->countPrimaries())
    {
        abort(QString("Bad primary # (%1) for event # %2").arg(iPrimary).arg(CurrentEvent));
        return;
    }
    ParticleRecord = EventRecord->getPrimaryParticleRecords().at(iPrimary);
    gotoFirstStep();
}

QString ATrackRec_SI::recordToString(bool includeSecondaries)
{
    QString s;
    if (ParticleRecord) ParticleRecord->logToString(s, 0, includeSecondaries);
    else abort(RecordNotSet);
    return s;
}

QVariantList ATrackRec_SI::getTrackRecord()
{
    QVariantList vl;

    if (ParticleRecord)
    {
        vl << ParticleRecord->ParticleName
           << (bool)ParticleRecord->getSecondaryOf()
           << (int)ParticleRecord->getSecondaries().size()
           << (int)ParticleRecord->getSteps().size();
    }
    else abort(RecordNotSet);

    return vl;
}

QString ATrackRec_SI::getProductionProcess()
{
    if (ParticleRecord)
    {
        const AParticleTrackingRecord * parent = ParticleRecord->getSecondaryOf();
        if (!parent) return "";

        const std::vector<AParticleTrackingRecord *> & vecSec = parent->getSecondaries();
        const int size = (int)vecSec.size();
        int index = 0;
        for (;index < size; index++)
            if (vecSec[index] == ParticleRecord) break;
        if (index == size)
        {
            abort("Corruption in secondary record detected: this record not found in parent record");
            return "";
        }

        const std::vector<ATrackingStepData *> & vecSteps = parent->getSteps();
        const int numSteps = (int)vecSteps.size();
        for (int iS = numSteps - 1; iS > -1; iS--)
        {
            const std::vector<int> & thisStepSecs = vecSteps.at(iS)->Secondaries;
            for (const int & iSec : thisStepSecs)
                if (iSec == index)
                    return vecSteps.at(iS)->Process;
        }
        abort("Corruption in secondary record detected: secondary not found in the parent record");
    }
    else abort(RecordNotSet);
    return "";
}

int ATrackRec_SI::countSteps()
{
    if (ParticleRecord) return ParticleRecord->getSteps().size();

    abort(RecordNotSet);
    return 0;
}

int ATrackRec_SI::countSecondaries()
{
    if (ParticleRecord) return ParticleRecord->getSecondaries().size();

    abort(RecordNotSet);
    return 0;
}

void ATrackRec_SI::gotoFirstStep()
{
    if (ParticleRecord)
    {
        if (ParticleRecord->getSteps().empty())
        {
            abort("Error: container with step records is empty!");
            return;
        }
        CurrentStep = 0;
    }
    else abort(RecordNotSet);
}

void ATrackRec_SI::gotoLastStep()
{
    if (ParticleRecord)
    {
        if (ParticleRecord->getSteps().empty())
        {
            abort("Error: container with steps is empty!");
            return;
        }
        CurrentStep = (int)ParticleRecord->getSteps().size() - 1;
    }
    else abort(RecordNotSet);
}

bool ATrackRec_SI::makeStep()
{
    if (ParticleRecord)
    {
        if (CurrentStep < (int)ParticleRecord->getSteps().size() - 1)
        {
            CurrentStep++;
            return true;
        }
        else return false;
    }

    abort(RecordNotSet);
    return false;
}

void ATrackRec_SI::gotoStep(int iStep)
{
    if (ParticleRecord)
    {
        if (iStep < 0 || iStep >= (int)ParticleRecord->getSteps().size()) abort("Bad step number");
        else CurrentStep = iStep;
    }
    else abort(RecordNotSet);
}

bool ATrackRec_SI::gotoNextProcessStep(QString processName)
{
    if (ParticleRecord)
    {
        while ( CurrentStep < (int)ParticleRecord->getSteps().size() - 1)
        {
            CurrentStep++;
            if (ParticleRecord->getSteps().at(CurrentStep)->Process == processName) return true;
        }
    }
    else abort(RecordNotSet);

    return false;
}

bool ATrackRec_SI::gotoNextNonTransportationStep()
{
    if (ParticleRecord)
    {
        while ( makeStep() )
        {
            const QString & pr = ParticleRecord->getSteps().at(CurrentStep)->Process;
            if (pr == "T" || pr == "C" || pr == "O") continue;
            return true;
        }
        return false;
    }
    else abort(RecordNotSet);
    return false;
}

int ATrackRec_SI::getCurrentStep()
{
    if (ParticleRecord) return CurrentStep;

    abort(RecordNotSet);
    return 0;
}

QVariantList ATrackRec_SI::getPreStepRecord()
{
    return doGetStepRecord(true);
}

QVariantList ATrackRec_SI::getPostStepRecord()
{
    return doGetStepRecord(false);
}

QVariantList ATrackRec_SI::doGetStepRecord(bool flag_PreTrue_PostFalse)
{
    QVariantList vl;

    if (ParticleRecord)
    {
        if (CurrentStep < (int)ParticleRecord->getSteps().size())
        {
            ATrackingStepData * thisStep = ParticleRecord->getSteps()[CurrentStep];

            ATrackingStepData * prevStep = (CurrentStep != 0 ? ParticleRecord->getSteps()[CurrentStep-1] : thisStep);

            QVariantList posVL;
            if (flag_PreTrue_PostFalse)
                posVL << prevStep->Position[0] << prevStep->Position[1] << prevStep->Position[2];
            else
                posVL << thisStep->Position[0] << thisStep->Position[1] << thisStep->Position[2];
            vl.push_back(posVL);

            vl << (flag_PreTrue_PostFalse ? prevStep->Time : thisStep->Time);

            QVariantList vnode;
            int iStep = (flag_PreTrue_PostFalse ? CurrentStep - 1 : CurrentStep);
            if (iStep < 0) iStep = 0;
            for (; iStep > -2; iStep--)
            {
                if (iStep < 0)
                {
                    abort("Corrupted tracking history!");
                    return vl;
                }
                ATransportationStepData * trans = dynamic_cast<ATransportationStepData*>(ParticleRecord->getSteps()[iStep]);
                if (!trans) continue;

                vnode << trans->iMaterial;
                vnode << trans->VolName;
                vnode << trans->VolIndex;
                break;
            }
            vl.push_back(vnode);

            vl << (flag_PreTrue_PostFalse ? prevStep->Energy : thisStep->Energy);

            vl << thisStep->DepositedEnergy;

            vl << thisStep->Process;

            vl << thisStep->TargetIsotope;

            QVariantList svl;
            for (int & iSec : thisStep->Secondaries) svl << iSec;
            vl.push_back(svl);
        }
        else abort("Error: bad current step!");
    }
    else abort(RecordNotSet);

    return vl;
}

bool normVector(double * arr)
{
    double Norm = 0;
    for (int i=0 ;i<3; i++) Norm += arr[i] * arr[i];
    Norm = sqrt(Norm);
    if (Norm != 0)
    {
        for (int i=0; i<3; i++) arr[i] = arr[i]/Norm;
        return true;
    }
    return false;
}

QVariantList ATrackRec_SI::getDirectionsApproximation()
{
    QVariantList vl;

    if (ParticleRecord)
    {
        if (CurrentStep < 0) CurrentStep = 0; //forced first step if not initialized

        QVariantList inDir;
        QVariantList outDir;
        double delta[3];
        const ATrackingStepData * thisStep = ParticleRecord->getSteps().at(CurrentStep);
        if (CurrentStep != 0)
        {
            const ATrackingStepData * lastStep = ParticleRecord->getSteps().at(CurrentStep-1);
            for (int i=0; i<3; i++) delta[i] = thisStep->Position[i] - lastStep->Position[i];
            bool ok = normVector(delta);
            if (ok) inDir << delta[0] << delta[1] << delta[2];
        }
        if (CurrentStep != (int)ParticleRecord->getSteps().size())
        {
            const ATrackingStepData * nextStep = ParticleRecord->getSteps().at(CurrentStep+1);
            for (int i=0; i<3; i++) delta[i] = nextStep->Position[i] - thisStep->Position[i];
            bool ok = normVector(delta);
            if (ok) outDir << delta[0] << delta[1] << delta[2];
        }
        vl.push_back(inDir);
        vl.push_back(outDir);
    }
    else abort(RecordNotSet);

    return vl;
}

bool ATrackRec_SI::hadPriorInteraction()
{
    if (ParticleRecord)
    {
        int iStep = CurrentStep;
        while (iStep > 2) // note iStep-- below: no need to test Step=0 and the last step
        {
            iStep--;
            const QString & Proc = ParticleRecord->getSteps().at(iStep)->Process;
            if (Proc != "T") return true;
        }
        return false;
    }
    else abort(RecordNotSet);
    return false;
}

void ATrackRec_SI::enterSecondary(int indexOfSecondary)
{
    if (ParticleRecord)
    {
        if (indexOfSecondary > -1 && indexOfSecondary < (int)ParticleRecord->getSecondaries().size())
        {
            ParticleRecord = ParticleRecord->getSecondaries().at(indexOfSecondary);
            ReturnStepIndex.push_back(CurrentStep);
            CurrentStep = 0;
        }
        else abort("Bad index of secondary");
    }
    else abort(RecordNotSet);
}

void ATrackRec_SI::exitSecondary()
{
    if (ParticleRecord)
    {
        if (ParticleRecord->getSecondaryOf() == nullptr)
        {
            abort("Cannot exitSecondary: The currently selected particle is primary");
            return;
        }
        ParticleRecord = ParticleRecord->getSecondaryOf();

        if (!ReturnStepIndex.empty())
        {
            CurrentStep = ReturnStepIndex.back();
            ReturnStepIndex.pop_back();
        }
        else
        {
            qWarning() << "Unexpected behavior: cannot retrieve the stored return step index";
            CurrentStep = 0;
        }
        return;
    }
    abort(RecordNotSet);
}
