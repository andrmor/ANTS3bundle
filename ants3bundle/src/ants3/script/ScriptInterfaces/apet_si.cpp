#include "apet_si.h"
#include "ageometryhub.h"
#include "avector.h"
#include "afiletools.h"
#include "ascripthub.h"

#include <iostream>
#include <fstream>
#include <ostream>
#include <ios>

#include <QDebug>
#include <QProcess>
#include <QDir>

APet_si::APet_si() :
    AScriptInterface() {}

void APet_si::createScanner(QString scannerName, double scannerRadius, double crystalDepth, double crystalSize, double minAngle_deg)
{
    QString castorStr;
    const QStringList environment = QProcess::systemEnvironment();
    for (const QString & s : environment)
        if (s.contains("CASTOR_CONFIG="))
        {
            castorStr = s;
            castorStr.remove("CASTOR_CONFIG=");
            break;
        }

    if (castorStr.isEmpty())
    {
        abort("System environmental variable CASTOR_CONFIG is not configured!");
        return;
    }
    qDebug() << castorStr;

    QDir castorDir(castorStr);
    if (!castorDir.exists())
    {
        abort("System environmental variable CASTOR_CONFIG points to non-existent directory!");
        return;
    }

    QDir scannerDir(castorStr + "/scanner");
    if (!scannerDir.exists())
    {
        abort("Scanner directory not found!");
        return;
    }

    size_t numScint = AGeometryHub::getConstInstance().countScintillators();
    if (numScint == 0)
    {
        abort("Current configuration does not have defined scintillators!");
        return;
    }

    bool ok = makeLUT(castorStr + "/scanner/" + scannerName + ".lut");
    if (!ok) return;

    QString numScintStr = QString::number(numScint);

    QString header =
        "modality: PET\n"
        "scanner name: " + scannerName + "\n"
        "scanner radius: " + QString::number(scannerRadius) + "\n"
        "number of layers: 1\n"
        "number of elements: " + numScintStr + "\n"
        "number of crystals in layer: " + numScintStr + "\n"
        "crystals size depth: " + QString::number(crystalDepth) + "\n"
        "crystals size transaxial: " + QString::number(crystalSize) + "\n"
        "crystals size axial: " + QString::number(crystalSize) + "\n"
        "voxels number transaxial: 256\n"
        "voxels number axial: 128\n"
        "field of view transaxial: 200.0\n"
        "field of view axial: 100.0\n"
        "min angle difference: " + QString::number(minAngle_deg) + "\n"
        "description: Auto-generated by ANTS3\n";

    ftools::saveTextToFile(header, castorStr + "/scanner/" + scannerName + ".hscan");
}

bool APet_si::makeLUT(QString fileName)
{
    std::ofstream outStream(fileName.toLatin1().data(), std::ios::out | std::ios::binary );
    if (!outStream.is_open())
    {
        abort("Cannot open file for writing: " + fileName);
        return false;
    }

    const AGeometryHub & GeoHub = AGeometryHub::getConstInstance();

    std::vector<AVector3> pos;
    GeoHub.getScintillatorPositions(pos);
    std::vector<AVector3> ori;
    GeoHub.getScintillatorOrientations(ori);

    for (size_t iScint = 0; iScint < pos.size(); iScint++)
    {
        for (size_t i = 0; i < 3; i++)
        {
            float tmp = (float)pos[iScint][i];
            outStream.write((char*)&tmp, sizeof(float));
        }
        for (size_t i = 0; i < 3; i++)
        {
            float tmp = (float)ori[iScint][i];
            outStream.write((char*)&tmp, sizeof(float));
        }
    }
    outStream.close();
    return true;
}

#include "apeteventbuilder.h"
void APet_si::buildEventsFromDeposition(QString depositionFileName, QString eventsFileName)
{
    size_t numScint = AGeometryHub::getConstInstance().countScintillators();
    APetEventBuilder eb(numScint, depositionFileName.toLatin1().data(), false);
    eb.makeEvents(eventsFileName.toLatin1().data(), false);
}

#include "apetcoincidencefinder.h"
void APet_si::findCoincidences(QString eventsFileName, QString coincFileName, bool writeToF)
{
    size_t numScint = AGeometryHub::getConstInstance().countScintillators();
    APetCoincidenceFinder cf(numScint, eventsFileName.toLatin1().data(), false);
    bool ok = cf.findCoincidences(coincFileName.toLatin1().data(), writeToF);
    if (!ok)
        abort(cf.ErrorString);
}

void APet_si::reconstructConfigureVoxels(int numX, int numY, int numZ, double sizeX, double sizeY, double sizeZ)
{
    if (numX < 1 || numY < 1 || numZ < 1)
    {
        abort("Number of voxel for PET reconstruction should be positive");
        return;
    }

    if (sizeX <= 0 || sizeY <= 0 || sizeZ <= 0)
    {
        abort("Voxel sizes for PET reconstruction should be positive");
        return;
    }

    NumVoxels  = {numX,  numY,  numZ};
    SizeVoxels = {sizeX, sizeY, sizeZ};
}

#include <QProcess>
#include <QApplication>
#include <QThread>
void APet_si::reconstruct(QString coincFileName, QString outDir, int numThreads)
{
    Process = new QProcess();
    Process->setProcessChannelMode(QProcess::MergedChannels);

    bool isRunning = true;
    QObject::connect(Process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished), [&isRunning](){isRunning = false; qDebug() << "----CASTOR FINISHED!-----";});
    //QObject::connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), [=](int exitCode, QProcess::ExitStatus exitStatus){ /* ... */ });

    QObject::connect(Process, &QProcess::readyReadStandardOutput, this, &APet_si::onReadReady);

    //castor-recon -df Tor.cdh -opti MLEM -it 10:16 -proj joseph -conv gaussian,2.0,2.5,3.5::psf -dim 128,128,128 -vox 3.0,3.0,3.0 -dout /home/andr/WORK/ANTS3/castor/Out/Tor/images
    QString program = "castor-recon";
    QStringList args;
    args << "-df" << coincFileName;
    args << "-th" << QString::number(numThreads);
    args << "-opti" << "MLEM";                      // !
    args << "-it" << "10:16";                       // !
    args << "-proj" << "joseph";                    // !
    args << "-conv" << "gaussian,2.0,2.5,3.5::psf"; // !
    //args << "-dim" << "128,128,128";
    args << "-dim" << QString("%1,%2,%3").arg(NumVoxels[0]).arg(NumVoxels[1]).arg(NumVoxels[2]);
    //args << "-vox" << "3.0,3.0,3.0";
    args << "-vox" << QString("%1,%2,%3").arg(SizeVoxels[0]).arg(SizeVoxels[1]).arg(SizeVoxels[2]);
    args << "-dout" << outDir;

    qDebug() << "Starting external process:" << program << " with arguments:\n" << args;

    Process->start(program, args);
    bool ok = Process->waitForStarted(1000);
    if (!ok)
    {
        abort("Failed to start reconstruction using castor-recon");
        return;
    }

    while (isRunning)
    {
        //bool ok = Process->waitForFinished(100); // ms
        //if (ok) break;

        QThread::usleep(100);
        QApplication::processEvents();

        if (AScriptHub::isAborted(Lang))
        {
            Process->terminate();
            break;
        }
    }

    QString err = Process->errorString();
    if (!err.isEmpty() && err != "Unknown error")
        abort("Reconstruction failed:\n" + err);
}

void APet_si::onReadReady()
{
    const QString in = Process->readAllStandardOutput();

    const QStringList input = in.split('\n', Qt::SkipEmptyParts);
    for (const QString & message : input)
        AScriptHub::getInstance().outputText(message, Lang);
}

#include <QVariantList>
QVariantList APet_si::loadImage(QString fileName)
{
    QVariantList res;

    std::ifstream inStream;
    inStream.open(fileName.toLatin1().data(), std::ios::in | std::ios::binary);

    if (!inStream.is_open() || inStream.fail() || inStream.bad())
    {
        abort("Cannot open image file: " + fileName);
        return res;
    }

    float buffer;
    for (int iz = 0; iz < 128; iz++)
    {
        QVariantList frame;
        for (int iy = 0; iy < 128; iy++)
        {
            //qDebug() << "---"<<iy<<"---";
            QVariantList el;
            for (int ix = 0; ix < 128; ix++)
            {
                inStream.read((char*)&buffer,   sizeof(float));
                //if (buffer != 0) qDebug() << buffer;
                el << buffer;
            }
            frame.push_back(el);
        }
        res.push_back(frame);
    }

    return res;
}
